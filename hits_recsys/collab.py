# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_collab.ipynb.

# %% auto 0
__all__ = ['read_movielens', 'SavePkl', 'normalize', 'CollabUserBased', 'train', 'pred', 'eval']

# %% ../nbs/01_collab.ipynb 3
from fastprogress.fastprogress import progress_bar
import pandas as pd
import torch, torch.nn.functional as F
from torch import tensor
from fastai.learner import to_device, default_device
from fastcore.all import *

# %% ../nbs/01_collab.ipynb 7
def read_movielens(ratings_path, movies_path):
    kw1 = dict(sep='::', names = ['userId','movieId','rating'], usecols=(0,1,2), engine='python')
    kw2 = kw1 | dict(names = ['movieId','title'], usecols=(0,1), encoding='ISO-8859-1')
    r, m = pd.read_csv(ratings_path, **kw1), pd.read_csv(movies_path, **kw2)
    return r.merge(m)

# %% ../nbs/01_collab.ipynb 15
class SavePkl:
    def save(self,fname='./out.pkl'):
        with open(fname,'wb') as f:
            save_pickle(f, self)
    def load(self,fname):
        with open(fname,'rb') as f:
            return load_pickle(f)

# %% ../nbs/01_collab.ipynb 16
def normalize(df, users_means=None):
    if users_means is None: users_means = df.groupby('userId')['rating'].mean()
    df['rating'] -= df['userId'].map(users_means)
    return df, users_means


class CollabUserBased(SavePkl):
    def __init__(self, device=None): 
        self.device = ifnone(device, default_device())
    
    def fit(self, dls):
        ys, self.means = normalize(dls.xs.join(dls.ys))
        self.means = pd.concat([pd.Series([0]),self.means]) # fix indexing for 0 user
        xs, ys = tensor(dls.xs.values), tensor(ys['rating'].values)
        self.A =to_device(
            torch.sparse_coo_tensor(xs.T, ys.squeeze(),dtype=torch.float32).to_dense(),
            self.device)
    
    def predict(self, xb, yb=None,loss=F.mse_loss):
        means = self.means.values[xb[:,0]]
        u, m = xb.T
        ratings = torch.bmm((self.A[u] @ self.A.T)[:,None,:], self.A[:,m].T[...,None]).squeeze()/(self.A[u] @ self.A.T).sum(dim=1)
        if yb is not None: return (ratings, loss(ratings+means,yb[:,0]))
        return ratings+means

    def recommend(self, user:int, topk=3, filter_seen=True):
        m = self.A[:,A[user]==0] if filter_seen else self.A
        return ((self.A @ self.A[user]) @ m).topk(topk)

# %% ../nbs/01_collab.ipynb 21
def train(model, dls, fname=None):
    model.fit(dls)
    model.save(fname)

def pred(model, dls, fname=None):
    if fname: model = model.load(fname)
    preds = [model.predict(*to_device(b)) for b in progress_bar(dls)]
    return torch.cat(preds)

def eval(model, dls, fname=None):
    if fname: model = model.load(fname)
    preds = [model.predict(*to_device(b)) for b in progress_bar(dls)]
    loss = torch.stack(list(L(preds).itemgot(1))).mean()
    return loss
