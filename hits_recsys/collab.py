# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_collab.ipynb.

# %% auto 0
__all__ = ['read_movielens', 'dataloaders', 'SavePkl', 'normalize', 'CollabUserBased', 'train', 'pred', 'eval']

# %% ../nbs/01_collab.ipynb 3
from fastprogress.fastprogress import progress_bar
import pandas as pd
import torch, torch.nn.functional as F
from torch import tensor
from fastai.collab import to_device, default_device, CollabDataLoaders
from fastcore.all import *

# %% ../nbs/01_collab.ipynb 7
def read_movielens(ratings_path, movies_path):
    kw1 = dict(sep='::', names = ['userId','movieId','rating'], usecols=(0,1,2), engine='python')
    kw2 = kw1 | dict(names = ['movieId','title'], usecols=(0,1), encoding='ISO-8859-1')
    r, m = pd.read_csv(ratings_path, **kw1), pd.read_csv(movies_path, **kw2)
    return r.merge(m)

# %% ../nbs/01_collab.ipynb 10
def dataloaders(df, bs=128):
    def encode(self, movies):
        return self.classes['title'].map_objs(movies)
    def decode(self, indices):
        return self.classes['title'].map_ids(indices)
    dls = CollabDataLoaders.from_df(df, item_name='title', bs=bs, valid_pct=0.0)
    dls.__class__.encode = encode
    dls.__class__.decode = decode
    return dls

# %% ../nbs/01_collab.ipynb 16
class SavePkl:
    def save(self,fname):
        Path(fname).parent.mkdir(parents=True,exist_ok=True)
        with open(fname,'wb') as f:
            save_pickle(f, self)
    def load(self,fname):
        with open(fname,'rb') as f:
            self.__dict__.update(load_pickle(f).__dict__)

# %% ../nbs/01_collab.ipynb 17
def normalize(df, users_means=None):
    '''get normalized ratings for each user'''
    if users_means is None: users_means = df.groupby('userId')['rating'].mean()
    df['rating'] -= df['userId'].map(users_means)
    return df, users_means


class CollabUserBased(SavePkl):
    '''Basic model for collaborative filtering'''
    def __init__(self, device=None): 
        self.device = ifnone(device, default_device())
    
    def fit(self, dls):
        ys, self.means = normalize(dls.xs.join(dls.ys))
        self.means = tensor(pd.concat([pd.Series([0]),self.means]), device=self.device) # fix indexing for 0 user
        xs, ys = tensor(dls.xs.values), tensor(ys['rating'].values)
        self.A = torch.sparse_coo_tensor(xs.T, ys.squeeze(),dtype=torch.float32, device=self.device).to_dense()

    
    def predict(self, xb, yb=None,loss=F.mse_loss):
        means = self.means[xb[:,0]]
        u, m = xb.T
        ratings = torch.bmm((self.A[u] @ self.A.T)[:,None,:], self.A[:,m].T[...,None]).squeeze()/(self.A[u] @ self.A.T).sum(dim=1)
        if yb is not None: return (ratings, loss(ratings+means,yb[:,0]))
        return ratings+means

    def recommend(self, movies: list, ratings: list, topk=5, filter_seen=True):
        user_emb = self.user_embed(movies,ratings)
        m = self.A[:,user_emb==0] if filter_seen else self.A
        return ((self.A @ user_emb) @ m).topk(topk)

    def user_embed(self, movies: list, ratings: list):
        ratings = tensor(ratings, dtype=torch.float32, device=self.device)
        emb = torch.zeros(self.A.shape[-1], device=self.device)
        emb[movies] = ratings - ratings.mean()
        return emb

    def similar_movies(self,movie_id: int, topk=5):
        return (self.A[:,movie_id] @ self.A).topk(topk+1).indices[1:]

# %% ../nbs/01_collab.ipynb 24
def train(model, dls, fname=None):
    model.fit(dls)
    model.save(fname)

def pred(model, dls):
    preds = [model.predict(*to_device(b)) for b in progress_bar(dls)]
    return torch.cat(preds)

def eval(model, dls):
    preds = [model.predict(*to_device(b)) for b in progress_bar(dls)]
    loss = torch.stack(list(L(preds).itemgot(1))).mean()
    return loss
