# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_collab.ipynb.

# %% auto 0
__all__ = ['SavePT', 'read_movielens', 'TfmdDataset', 'CollabUserBased', 'ModelService']

# %% ../nbs/01_collab.ipynb 3
from fastprogress.fastprogress import progress_bar
import pandas as pd
import torch, torch.nn.functional as F
from torch import tensor
from fastai.collab import to_device, default_device, CategoryMap, DataLoader
from fastcore.all import *
from itertools import chain

# %% ../nbs/01_collab.ipynb 4
@patch
def pprint(l: L): print('\n'.join(l.map(str)))

class SavePT:
    def save(self, fname):
        Path(fname).parent.mkdir(parents=True,exist_ok=True)
        torch.save(self, fname)
    def load(self, fname):
        self.__dict__.update(torch.load(fname, map_location=default_device()).__dict__)
    
    @classmethod
    def from_folder(cls, dir, **kwargs):
        '''Loads attributes from pt,pth files, filenames are mapped to attr names'''
        dir = Path(dir)
        obj = cls(**kwargs)
        patterns = chain(*L('**/*.pt', '**/*.pth').map(dir.glob))
        for fname in patterns:
            o = torch.load(fname, map_location=default_device())
            setattr(obj, fname.stem, o)
        return obj

# %% ../nbs/01_collab.ipynb 8
def read_movielens(ratings_path, movies_path):
    kw1 = dict(sep='::', names = ['userId','movieId','rating'], usecols=(0,1,2), engine='python')
    kw2 = kw1 | dict(names = ['movieId','title'], usecols=(0,1), encoding='ISO-8859-1')
    r, m = pd.read_csv(ratings_path, **kw1), pd.read_csv(movies_path, **kw2)
    return r.merge(m)

# %% ../nbs/01_collab.ipynb 12
class TfmdDataset(SavePT):
    def __init__(self, df):
        self.movie_map = CategoryMap(df.title)
        self.user_map =  CategoryMap(df.userId)
        self.xs = tensor([self.user_map.map_objs(df.userId), self.movie_map.map_objs(df.title)]).T
        if hasattr(df, 'rating'): self.ys = tensor(df.rating, dtype=torch.float32)
    def encode(self, movies): return self.movie_map.map_objs(movies)
    def decode(self, movie_ids): return self.movie_map.map_ids(movie_ids)
    def __getitem__(self,i): 
        return (self.xs[i],self.ys[i]) if hasattr(self,'ys') else (self.xs[i],)
    def __len__(self): return len(self.xs)
    @delegates(DataLoader.__init__)
    def dls(self,bs=64, **kwargs):
        return DataLoader(self, batch_size=bs, **kwargs)

# %% ../nbs/01_collab.ipynb 17
class CollabUserBased(SavePT):
    '''Basic model for collaborative filtering'''
    def __init__(self, device=None): 
        self.device = ifnone(device, default_device())
    
    def norm(self, x, m, std=None): return (x-m)/std if std else (x-m)/m
    def denorm(self, x, m, std=None): return x*std+m if std else x*m+m
    
    def fit(self, ds):
        A = to_device(torch.sparse_coo_tensor(ds.xs.T,ds.ys,dtype=torch.float32).to_dense())
        self.means = A.sum(dim=1)/A.count_nonzero(dim=1)
        mask = A!=0
        means = ((mask)*self.means[:,None])
        A[mask] = self.norm(A[mask], means[mask])
        self.A = A

    def predict(self, xb, yb=None):
        u, m = xb.T
        means = self.means[u]
        u, m = self.A[u], self.A[:,m].T
        ratings = torch.bmm((u @ self.A.T)[:,None,:], m[...,None]).squeeze()/len(u[0])
        ratings = self.denorm(ratings, means)
        if yb is not None: return (ratings, F.mse_loss(ratings,yb))
        return ratings

    def recommend(self, movies, ratings, topk=5, filter_seen=True):
        u = self.user_embed(movies, ratings)
        # res = self.denorm(((self.A @ u) @ self.A)/(self.A!=0).sum(0), ratings.mean()) works for ratings but not for recommendations
        res = self.denorm(((self.A @ u) @ self.A), ratings.mean())
        if not filter_seen: return res.topk(topk)
        res = res.topk(topk + len(movies))
        mask = ~torch.isin(res.indices,movies)
        return (res[0][mask][:topk], res[1][mask][:topk])

    def user_embed(self, movies, ratings):
        emb = torch.zeros(self.A.shape[-1], device=self.device)
        emb[movies] = self.norm(ratings, ratings.mean())
        return emb

    def similar_movies(self, movie_id: int, topk=5):
        return (self.A[:,movie_id].squeeze(-1) @ self.A).topk(topk+1).indices[1:]

# %% ../nbs/01_collab.ipynb 28
class ModelService(SavePT):
    def __init__(self, model: CollabUserBased=None, ds=None):
        self.model = model
        self.ds = ds
    def _movie_enc(self, movies): 
        return tensor(self.ds.encode(movies) if isinstance(movies[0],str) else movies, device=self.model.device)
    
    def save(self, dir):
        dir = Path(dir)
        self.ds.save(dir/'ds.pt')
        self.model.save(dir/'model.pt')
    
    def load(self, dir):
        self.__dict__ = self.from_folder(dir).__dict__
        
    def train(self, ds=None, model = None):
        '''Train model from scratch on dataset'''
        self.model = ifnone(model, self.model)
        ds = ifnone(ds,self.ds)
        self.model.fit(ds)
    
    def pred(self, ds=None, bs=8192):
        '''Get rating predictions for dataset'''
        dls = ifnone(ds,self.ds).dls(bs)
        preds = torch.cat([self.model.predict(*to_device(b, self.model.device))[0] for b in progress_bar(dls)])
        return preds.tolist()

    def eval(self, ds=None, bs=8192):
        '''Evaluate RMSE for dataset'''
        dls = ifnone(ds,self.ds).dls(bs)
        loss = torch.stack([self.model.predict(*to_device(b, self.model.device))[1] for b in progress_bar(dls)]).mean()
        return torch.sqrt(loss).item()

    def recommend(self, movies: list, ratings: list, topk=5, filter_seen=True):
        '''Recommend top k movies by user wih list of movies and ratings'''
        movies = self._movie_enc(movies)
        ratings = tensor(ratings, device=self.model.device, dtype=torch.float)
        return self.ds.decode(self.model.recommend(movies, ratings, topk, filter_seen)[1])

    def similar_movies(self, movie:str, topk=5):
        '''Find top k similar movies'''
        movie = self._movie_enc([movie])
        ms = self.model.similar_movies(movie, topk)
        return self.ds.decode(ms)
